<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Water Sort Puzzle â€” With Sound (Demo)</title>
<style>
  :root{
    --bg:#efeef6; --card:#fff; --tube-bg:#f7f7fb;
    --accent:#6b7cff; --muted:#7b7f8a;
  }
  body{font-family:Inter,system-ui,Segoe UI,Roboto,Arial;margin:20px;background:linear-gradient(180deg,#f3f2fb,#efeef6);color:#222;}
  .wrap{max-width:900px;margin:0 auto;}
  .top{display:flex;align-items:center;gap:16px;margin-bottom:14px}
  h1{margin:0;font-size:22px}
  .controls{margin-left:auto;display:flex;gap:10px;align-items:center}
  .card{background:var(--card);border-radius:14px;padding:18px;box-shadow:0 10px 30px rgba(20,30,60,0.06)}
  .board{display:flex;gap:18px;flex-wrap:wrap;padding:18px;margin-top:14px;justify-content:center}
  .tube{width:78px;height:220px;border-radius:12px;background:var(--tube-bg);box-shadow:inset 0 6px 12px rgba(0,0,0,0.03);display:flex;flex-direction:column-reverse;align-items:center;padding:8px;position:relative;cursor:pointer;transition:transform .12s}
  .tube.selected{outline:3px solid rgba(107,124,255,0.16);transform:translateY(-6px)}
  .slot{width:68px;border-radius:8px;height:44px;margin:6px 0;box-shadow:inset 0 -3px 8px rgba(0,0,0,0.04)}
  .tube.empty{opacity:.85}
  .row-controls{display:flex;gap:10px;align-items:center;margin-top:14px}
  button{background:#f3f7ff;border:0;padding:8px 12px;border-radius:10px;cursor:pointer}
  .big{padding:10px 16px}
  .muted{color:var(--muted);font-size:14px}
  .bottom{display:flex;gap:22px;align-items:center;margin-top:14px;justify-content:center}
  .moves{color:var(--muted)}
  .levelnum{color:var(--muted)}
  .small{font-size:13px;color:var(--muted)}
  .footer-note{margin-top:12px;color:var(--muted);font-size:13px;text-align:center}
  @media (max-width:600px){
    .tube{width:60px;height:190px}
    .slot{width:52px;height:38px}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <h1>Water Sort Puzzle â€” Demo</h1>
    <div class="controls">
      <div class="small">Volume</div>
      <input type="range" id="volume" min="0" max="1" step="0.01" value="0.9">
      <button id="mute">Mute</button>
    </div>
  </div>

  <div class="card" id="gamecard">
    <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
      <div class="levelnum">Level: <span id="level">1</span></div>
      <div class="moves">Moves: <span id="moves">0</span></div>
      <div style="margin-left:auto;display:flex;gap:8px">
        <button id="undo" title="Undo">Undo</button>
        <button id="restart" title="Restart">Restart</button>
        <button id="newlevel" title="New Level">New Level</button>
      </div>
    </div>

    <div id="board" class="board" aria-live="polite" style="margin-top:18px"></div>

    <div class="row-controls">
      <button id="hint">Hint (demo)</button>
      <button id="demo-pour">Demo: Pour Sequence</button>
      <div class="muted" style="margin-left:auto">Click a tube to select â†’ click another to pour</div>
    </div>

    <div class="footer-note">This is a demo. Integrate sounds by calling the functions in the <code>sounds</code> object.</div>
  </div>
</div>

<script>
/* =========================
   WebAudio Sound Engine
   (integrated & lightweight version)
   ========================= */
let audioCtx = null;
let masterGain = null;
let volumeValue = 0.9;
let isMuted = false;

function ensureAudioCtx() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = volumeValue;
    masterGain.connect(audioCtx.destination);
  }
}
function noiseBuffer(durationSeconds=0.5) {
  ensureAudioCtx();
  const sr = audioCtx.sampleRate;
  const buffer = audioCtx.createBuffer(1, sr * durationSeconds, sr);
  const data = buffer.getChannelData(0);
  for (let i=0;i<data.length;i++){
    data[i] = (Math.random()*2-1) * Math.exp(-3 * i / data.length);
  }
  return buffer;
}
const sounds = {
  playClick(){ ensureAudioCtx(); if (!audioCtx || isMuted || volumeValue<=0) return;
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator(); o.type='square'; o.frequency.setValueAtTime(900, now);
    const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001, now);
    g.gain.linearRampToValueAtTime(0.08, now+0.002); g.gain.exponentialRampToValueAtTime(0.0001, now+0.09);
    o.connect(g).connect(masterGain); o.start(now); o.stop(now+0.09);
  },
  playPour(repeat=1, durationPer=160){ ensureAudioCtx(); if (!audioCtx || isMuted || volumeValue<=0) return;
    const playOnce = (t0, durationMs) => {
      // low rumble
      const low = audioCtx.createOscillator(); low.type='sine'; low.frequency.setValueAtTime(120, t0);
      const lowG = audioCtx.createGain(); lowG.gain.setValueAtTime(0.0001, t0);
      lowG.gain.linearRampToValueAtTime(0.02, t0+0.03); lowG.gain.linearRampToValueAtTime(0.0005, t0+durationMs/1000-0.05);
      low.connect(lowG).connect(masterGain);
      // whoosh
      const who = audioCtx.createOscillator(); who.type='sawtooth';
      who.frequency.setValueAtTime(220, t0); who.frequency.linearRampToValueAtTime(420, t0+durationMs/1000);
      const bp = audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.Q.value=0.7; bp.frequency.setValueAtTime(1200,t0);
      bp.frequency.linearRampToValueAtTime(3000,t0+durationMs/1000);
      const whoG = audioCtx.createGain(); whoG.gain.setValueAtTime(0.0001,t0); whoG.gain.linearRampToValueAtTime(0.06,t0+0.03); whoG.gain.linearRampToValueAtTime(0.001,t0+durationMs/1000-0.03);
      who.connect(bp).connect(whoG).connect(masterGain);
      low.start(t0); low.stop(t0+durationMs/1000+0.02); who.start(t0); who.stop(t0+durationMs/1000+0.02);
      // tiny pop
      const pop = audioCtx.createOscillator(); pop.type='triangle';
      const popG = audioCtx.createGain();
      popG.gain.setValueAtTime(0.0001, t0 + durationMs/1000 - 0.03);
      popG.gain.linearRampToValueAtTime(0.09, t0 + durationMs/1000 - 0.02);
      popG.gain.linearRampToValueAtTime(0.0001, t0 + durationMs/1000 + 0.02);
      pop.frequency.setValueAtTime(880, t0 + durationMs/1000 - 0.03);
      pop.frequency.exponentialRampToValueAtTime(1200, t0 + durationMs/1000 - 0.01);
      pop.connect(popG).connect(masterGain);
      pop.start(t0 + durationMs/1000 - 0.03); pop.stop(t0 + durationMs/1000 + 0.02);
    };
    const start = audioCtx.currentTime;
    for (let i=0;i<repeat;i++){
      playOnce(start + (i*(durationPer-40))/1000, durationPer);
    }
  },
  playSplash(){ ensureAudioCtx(); if (!audioCtx || isMuted || volumeValue<=0) return;
    const now = audioCtx.currentTime;
    const buf = noiseBuffer(0.45);
    const src = audioCtx.createBufferSource(); src.buffer = buf;
    const flt = audioCtx.createBiquadFilter(); flt.type='highpass'; flt.frequency.value=700;
    const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.2, now+0.01); g.gain.exponentialRampToValueAtTime(0.001, now+0.35);
    src.connect(flt).connect(g).connect(masterGain); src.start(now); src.stop(now+0.45);
  },
  playError(){ ensureAudioCtx(); if (!audioCtx || isMuted || volumeValue<=0) return;
    const now = audioCtx.currentTime; const o = audioCtx.createOscillator(); o.type='sawtooth'; o.frequency.setValueAtTime(320, now); o.frequency.exponentialRampToValueAtTime(140, now+0.12);
    const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.12, now+0.005); g.gain.exponentialRampToValueAtTime(0.0001, now+0.18);
    o.connect(g).connect(masterGain); o.start(now); o.stop(now+0.2);
  },
  playUndo(){ ensureAudioCtx(); if (!audioCtx || isMuted || volumeValue<=0) return;
    const now = audioCtx.currentTime; const o = audioCtx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(520, now); o.frequency.exponentialRampToValueAtTime(240, now+0.22);
    const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.06, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+0.28);
    o.connect(g).connect(masterGain); o.start(now); o.stop(now+0.3);
  },
  playSuccess(){ ensureAudioCtx(); if (!audioCtx || isMuted || volumeValue<=0) return;
    const now = audioCtx.currentTime; const notes = [660,880,1100].map(n=>n*0.5);
    notes.forEach((freq,i)=>{
      const t = now + i*0.12;
      const o = audioCtx.createOscillator(); o.type='triangle'; o.frequency.setValueAtTime(freq,t);
      const g = audioCtx.createGain(); g.gain.setValueAtTime(0.0001,t); g.gain.linearRampToValueAtTime(0.09,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+0.36);
      o.connect(g).connect(masterGain); o.start(t); o.stop(t+0.38);
    });
    setTimeout(()=> this.playSplash(), 360);
  }
};

/* Resume audio context on first interaction for autoplay policies */
['click','touchstart','keydown'].forEach(ev=>{
  window.addEventListener(ev, function once(){
    if (!audioCtx) try { ensureAudioCtx(); } catch(e){}
    if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    window.removeEventListener(ev, once);
  }, {passive:true});
});
document.getElementById('volume').addEventListener('input', e=>{
  volumeValue = parseFloat(e.target.value);
  if (!audioCtx) ensureAudioCtx();
  if (masterGain) masterGain.gain.setValueAtTime(volumeValue, audioCtx.currentTime);
});
document.getElementById('mute').addEventListener('click', ()=>{
  isMuted = !isMuted;
  document.getElementById('mute').textContent = isMuted ? 'Unmute' : 'Mute';
});

/* =========================
   Game Logic
   ========================= */
// Configurable values
const TUBE_CAPACITY = 4;    // slots per tube
let NUM_COLORS = 3;         // starting difficulty
let NUM_TUBES = NUM_COLORS + 2; // always have 2 empty tubes

// Color palette (use CSS backgrounds)
const COLOR_MAP = [
  '#4AA3FF', // blue
  '#2ECC71', // green
  '#FF6B6B', // red
  '#FFD166', // yellow
  '#A084FF', // purple
  '#FF9F43'  // orange
];

let tubes = [];        // array of arrays (bottom->top: index 0 is bottom)
let selected = null;   // index of selected tube or null
let moves = 0;
let level = 1;
let undoStack = [];

// DOM refs
const board = document.getElementById('board');
const movesEl = document.getElementById('moves');
const levelEl = document.getElementById('level');

// Utility: deep clone tubes for undo
function cloneTubes(t) { return t.map(arr=>arr.slice()); }

// Generate solvable level:
// 1) Create NUM_COLORS tubes each filled with single color (capacity slots).
// 2) Add two empty tubes.
// 3) Perform many random legal moves to shuffle, ensuring solvable.
function generateLevel(colors, tubesCount, capacity=TUBE_CAPACITY, shuffleMoves=500) {
  NUM_COLORS = colors;
  NUM_TUBES = tubesCount;
  // start: color stacks
  const start = [];
  for (let i=0;i<colors;i++){
    const col = [];
    for (let k=0;k<capacity;k++) col.push(i);
    start.push(col);
  }
  // add empty tubes
  while (start.length < tubesCount) start.push([]);
  // perform random legal moves
  function legalMoves(state){
    const moves = [];
    for (let i=0;i<state.length;i++){
      if (state[i].length===0) continue;
      const topColor = state[i][state[i].length-1];
      // how many same color at top in from tube
      let countTop = 1;
      for (let s=state[i].length-2; s>=0; s--){
        if (state[i][s] === topColor) countTop++; else break;
      }
      for (let j=0;j<state.length;j++){
        if (i===j) continue;
        if (state[j].length === capacity) continue;
        if (state[j].length === 0 || state[j][state[j].length-1] === topColor) {
          // can pour up to min(available space, countTop)
          moves.push({from:i,to:j,amount:Math.min(capacity - state[j].length, countTop)});
        }
      }
    }
    return moves;
  }
  const state = cloneTubes(start);
  for (let m=0;m<shuffleMoves;m++){
    const L = legalMoves(state);
    if (L.length===0) break;
    const pick = L[Math.floor(Math.random()*L.length)];
    // execute move (pour amount)
    for (let a=0;a<pick.amount;a++){
      state[pick.to].push(state[pick.from].pop());
    }
  }
  return state;
}

// Render
function render() {
  board.innerHTML = '';
  tubes.forEach((tube, idx) => {
    const t = document.createElement('div');
    t.className = 'tube' + (tube.length===0 ? ' empty' : '') + (selected===idx ? ' selected' : '');
    t.dataset.idx = idx;
    t.setAttribute('role','button');
    t.setAttribute('aria-label','Tube ' + (idx+1));
    // Fill slots bottom-up (we render visually reversed: column-reverse style)
    const emptySlots = TUBE_CAPACITY - tube.length;
    // Add empty placeholders to keep height consistent
    for (let i=0;i<emptySlots;i++){
      const s = document.createElement('div'); s.className='slot'; s.style.background='transparent'; s.style.boxShadow='none';
      t.appendChild(s);
    }
    tube.forEach((colorIdx, i) => {
      const s = document.createElement('div'); s.className='slot';
      s.style.background = COLOR_MAP[colorIdx % COLOR_MAP.length];
      s.style.transition = 'background .12s';
      t.appendChild(s);
    });
    // click handler
    t.addEventListener('click', ()=> handleTubeClick(idx));
    board.appendChild(t);
  });
  movesEl.textContent = moves;
  levelEl.textContent = level;
}

// Pour logic: pour from 'from' to 'to' if legal. Returns amount poured or 0.
function tryPour(from, to) {
  if (from === to) { sounds.playError(); return 0; }
  const A = tubes[from], B = tubes[to];
  if (A.length === 0) { sounds.playError(); return 0; }
  if (B.length === TUBE_CAPACITY) { sounds.playError(); return 0; }
  const topA = A[A.length-1];
  if (B.length === 0 || B[B.length-1] === topA) {
    // determine how many continuous topA in A
    let countTop = 1;
    for (let i=A.length-2;i>=0;i--){
      if (A[i] === topA) countTop++; else break;
    }
    const space = TUBE_CAPACITY - B.length;
    const amount = Math.min(countTop, space);
    // commit for undo
    undoStack.push({tubes: cloneTubes(tubes), movesBefore: moves});
    for (let k=0;k<amount;k++){
      B.push(A.pop());
    }
    moves++;
    // play sounds
    sounds.playPour(amount, 160);
    setTimeout(()=> sounds.playSplash(), 140 + Math.max(0, amount-1)*120);
    return amount;
  } else {
    sounds.playError();
    return 0;
  }
}

function handleTubeClick(idx) {
  sounds.playClick();
  if (selected === null) {
    if (tubes[idx].length === 0) {
      // selecting empty tube does nothing
      selected = idx; render();
      return;
    }
    selected = idx;
    render();
  } else {
    // attempt pour from selected -> idx
    const from = selected, to = idx;
    const poured = tryPour(from, to);
    selected = null;
    render();
    if (poured>0) {
      // check win
      setTimeout(()=> {
        if (checkWin()) {
          sounds.playSuccess();
          alert('Level Complete! ðŸŽ‰');
        }
      }, 420);
    }
  }
}

// check win: every non-empty tube must contain only one color and be full (or allow full single-color)
function checkWin() {
  for (let t of tubes) {
    if (t.length === 0) continue;
    if (t.length !== TUBE_CAPACITY) return false;
    const first = t[0];
    for (let c of t) if (c !== first) return false;
  }
  return true;
}

// Undo
document.getElementById('undo').addEventListener('click', ()=> {
  if (undoStack.length === 0) { sounds.playError(); return; }
  const prev = undoStack.pop();
  tubes = cloneTubes(prev.tubes);
  moves = prev.movesBefore;
  sounds.playUndo();
  render();
});

// Restart
document.getElementById('restart').addEventListener('click', ()=> {
  sounds.playRestart();
  startLevel(level); // regenerate same level (for simplicity)
});

// New Level (increase difficulty)
document.getElementById('newlevel').addEventListener('click', ()=> {
  level++; NUM_COLORS = Math.min(6, Math.min(6, NUM_COLORS+1)); // cap at palette length
  NUM_TUBES = NUM_COLORS + 2;
  startLevel(level);
});

// Demo pour sequence button
document.getElementById('demo-pour').addEventListener('click', ()=> {
  // find a source with at least one pourable move
  for (let i=0;i<tubes.length;i++){
    for (let j=0;j<tubes.length;j++){
      if (i===j) continue;
      // quick simulate legal
      const A=tubes[i], B=tubes[j];
      if (A.length===0 || B.length===TUBE_CAPACITY) continue;
      if (B.length===0 || B[B.length-1]===A[A.length-1]) {
        sounds.playPour(1,160);
        setTimeout(()=> sounds.playSplash(), 160);
        return;
      }
    }
  }
  sounds.playError();
});

// hint (very naive): find first legal move and highlight
document.getElementById('hint').addEventListener('click', ()=> {
  for (let i=0;i<tubes.length;i++){
    for (let j=0;j<tubes.length;j++){
      if (i===j) continue;
      const A=tubes[i], B=tubes[j];
      if (A.length===0 || B.length===TUBE_CAPACITY) continue;
      if (B.length===0 || B[B.length-1]===A[A.length-1]) {
        // highlight briefly
        selected = i; render();
        setTimeout(()=> { selected = null; render(); }, 700);
        return;
      }
    }
  }
  sounds.playError();
});

/* Start level with solvable generator and reset variables */
function startLevel(lvl=1) {
  // difficulty mapping: increase colors slowly
  NUM_COLORS = Math.min(6, 2 + Math.floor((lvl-1)/1)); // start with 2 colors, add each level
  NUM_TUBES = NUM_COLORS + 2;
  tubes = generateLevel(NUM_COLORS, NUM_TUBES, TUBE_CAPACITY, 500);
  moves = 0; undoStack = []; selected = null;
  render();
}
startLevel(1);

/* Accessibility: keyboard navigation (optional)
   - Use number keys 1..N to select tubes; pressing twice attempts pour (first = select, second = target)
*/
window.addEventListener('keydown', (e)=>{
  if (!e.key) return;
  if (e.key >= '1' && e.key <= '9') {
    const idx = parseInt(e.key,10)-1;
    if (idx < tubes.length) handleTubeClick(idx);
  }
});

</script>
</body>
</html>
