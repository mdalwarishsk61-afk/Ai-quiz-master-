<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡§∞‡§Ç‡§ó ‡§Æ‡§ø‡§≤‡§æ‡§ì ‡§™‡§π‡•á‡§≤‡•Ä - Medium Level</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        .tube-container {
            width: 18vw;
            max-width: 80px;
            height: 30vh;
            max-height: 250px;
            margin: 10px;
            display: flex;
            flex-direction: column-reverse;
            position: relative;
            cursor: pointer;
            transition: transform 0.15s ease-in-out;
            align-items: center;
        }

        .tube {
            width: 100%;
            height: 100%;
            border: 3px solid #2d3748;
            border-bottom-left-radius: 40px;
            border-bottom-right-radius: 40px;
            border-top: none;
            position: relative;
            overflow: hidden;
            background-color: rgba(255, 255, 255, 0.1);
        }

        .tube::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: transparent;
            z-index: 10;
        }

        .tube.selected {
            transform: translateY(-10px);
            border-color: #f6ad55;
        }

        .tube-liquid-layer {
            height: 25%;
            width: 100%;
            position: absolute;
            bottom: 0;
            left: 0;
            transition: all 0.5s ease-in-out;
            box-shadow: 0 -1px 3px rgba(0, 0, 0, 0.2) inset;
        }

        .layer-1 { bottom: 0; }
        .layer-2 { bottom: 25%; }
        .layer-3 { bottom: 50%; }
        .layer-4 { bottom: 75%; }

        .pour-animation {
            animation: pour 0.5s forwards;
            z-index: 1000;
        }

        @keyframes pour {
            0% { transform: translate(0, 0) rotate(0deg); opacity: 1; }
            50% { transform: translate(50px, -50px) rotate(45deg); opacity: 0.8; }
            100% { transform: translate(100px, 0) rotate(0deg); opacity: 0; }
        }

        #game-board {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-end;
            padding: 10px;
            min-height: 40vh;
        }

        .tube-cap {
            width: 50%;
            height: 10px;
            background-color: #2d3748;
            border-radius: 50%;
            position: absolute;
            top: 0px;
            z-index: 20;
        }
        
        .loading {
            color: #9ca3af;
            font-size: 1.25rem;
            text-align: center;
            padding: 2rem;
        }
        
        @media (max-width: 640px) {
            .tube-container {
                width: 22vw;
                max-width: 70px;
                height: 25vh;
                margin: 5px;
            }
            
            #controls {
                flex-direction: column;
                gap: 10px;
                align-items: center;
            }
            
            #controls button {
                width: 80%;
                max-width: 200px;
            }
        }
    </style>
</head>
<body class="bg-gray-800 text-white min-h-screen flex flex-col items-center p-4 font-sans">

    <!-- Game Title and Status Bar -->
    <h1 class="text-3xl font-bold mb-4 text-yellow-300">‡§∞‡§Ç‡§ó ‡§Æ‡§ø‡§≤‡§æ‡§ì ‡§™‡§π‡•á‡§≤‡•Ä - Medium Level</h1>

    <div id="status-bar" class="flex justify-between w-full max-w-xl mb-6 p-3 bg-gray-700 rounded-lg shadow-lg">
        <div class="text-lg">
            <span class="font-semibold text-blue-300">‡§∏‡•ç‡§§‡§∞ (Level):</span>
            <span id="level-number">1</span>
        </div>
        <div class="text-lg">
            <span class="font-semibold text-green-300">‡§ö‡§æ‡§≤‡•á‡§Ç (Moves):</span>
            <span id="moves-counter">0</span>
        </div>
        <div class="text-lg">
            <span class="font-semibold text-purple-300">‡§≤‡§ï‡•ç‡§∑‡•ç‡§Ø (Target):</span>
            <span id="target-moves">-</span>
        </div>
    </div>

    <!-- Game Board -->
    <div id="game-board" class="w-full max-w-4xl bg-gray-700/50 p-4 rounded-xl shadow-2xl backdrop-blur-sm">
        <p class="loading">Loading Game...</p>
    </div>

    <!-- Controls -->
    <div id="controls" class="flex justify-center w-full max-w-xl mt-6 space-x-4">
        <button id="undo-button" class="px-6 py-3 bg-red-600 hover:bg-red-700 rounded-full font-bold text-lg shadow-xl transition disabled:opacity-50" disabled>
            ‡§µ‡§æ‡§™‡§∏ ‡§≤‡•á‡§Ç (Undo)
        </button>
        <button id="restart-button" class="px-6 py-3 bg-indigo-600 hover:bg-indigo-700 rounded-full font-bold text-lg shadow-xl transition">
            ‡§™‡•Å‡§®‡§É ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç (Restart)
        </button>
        <button id="hint-button" class="px-6 py-3 bg-yellow-600 hover:bg-yellow-700 rounded-full font-bold text-lg shadow-xl transition">
            ‡§∏‡§Ç‡§ï‡•á‡§§ (Hint)
        </button>
    </div>

    <!-- Win Modal -->
    <div id="win-modal" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center p-4 z-50">
        <div class="bg-gray-700 p-8 rounded-xl shadow-2xl text-center max-w-sm w-full border-4 border-yellow-400">
            <svg class="mx-auto h-16 w-16 text-yellow-400 mb-4 animate-bounce" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <h2 class="text-3xl font-extrabold text-yellow-300 mb-2">üéâ ‡§ú‡•Ä‡§§ ‡§ó‡§è! (Victory!)</h2>
            <p class="text-gray-200 mb-2">‡§Ü‡§™‡§®‡•á ‡§Ø‡§π ‡§∏‡•ç‡§§‡§∞ ‡§™‡•Ç‡§∞‡•Ä ‡§§‡§∞‡§π ‡§∏‡•á ‡§π‡§≤ ‡§ï‡§∞ ‡§≤‡§ø‡§Ø‡§æ ‡§π‡•à‡•§</p>
            <p class="text-gray-200 mb-4">‡§Ü‡§™‡§ï‡•Ä ‡§ö‡§æ‡§≤‡•á‡§Ç: <span id="final-moves" class="font-bold"></span></p>
            <button id="next-level-button" class="w-full px-6 py-3 bg-green-500 hover:bg-green-600 rounded-lg font-bold text-xl shadow-xl transition mb-2">
                ‡§Ö‡§ó‡§≤‡§æ ‡§∏‡•ç‡§§‡§∞ (Next Level)
            </button>
        </div>
    </div>

    <script type="module">
        // Game Constants and State
        const TUBE_CAPACITY = 4;
        let gameState = [];
        let history = [];
        let selectedTubeIndex = -1;
        let movesCount = 0;
        let level = 1;
        let targetMoves = 0;

        // Custom colors for medium difficulty
        const ALL_COLORS = [
            '#DC143C', // Crimson
            '#40E0D0', // Turquoise
            '#FFBF00', // Amber
            '#E6E6FA', // Lavender
            '#008080', // Teal
            '#36454F'  // Charcoal
        ];
        
        // Tone.js Sound Setup
        let isAudioReady = false;
        let PourSynth, ErrorSynth, WinPolySynth, HintSynth;

        function initAudio() {
            if (typeof Tone === 'undefined') {
                console.warn("Tone.js not loaded, audio disabled");
                return;
            }
            
            try {
                PourSynth = new Tone.Synth({
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.0, release: 0.1 }
                }).toDestination();

                ErrorSynth = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.005, decay: 0.05, sustain: 0.0, release: 0.05 }
                }).toDestination();

                WinPolySynth = new Tone.PolySynth(Tone.Synth).toDestination();
                
                HintSynth = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.01, decay: 0.2, sustain: 0.0, release: 0.1 }
                }).toDestination();
                
                isAudioReady = true;
            } catch (e) {
                console.error("Audio initialization failed:", e);
            }
        }

        function startAudio() {
            if (Tone.context.state !== 'running') {
                Tone.start().then(() => {
                    console.log("Audio Context Started.");
                    initAudio();
                }).catch(e => {
                    console.error("Failed to start audio:", e);
                });
            } else {
                initAudio();
            }
        }

        document.addEventListener('click', () => {
            if (!isAudioReady) {
                startAudio();
            }
        }, { once: true });

        function playSound(type) {
            if (!isAudioReady) return;
            try {
                if (type === 'pour') {
                    PourSynth.triggerAttackRelease("G4", "16n");
                } else if (type === 'error') {
                    ErrorSynth.triggerAttackRelease("C2", "64n");
                } else if (type === 'win') {
                    WinPolySynth.triggerAttackRelease(["C5", "E5", "G5", "C6"], "0.5");
                } else if (type === 'hint') {
                    HintSynth.triggerAttackRelease("E5", "8n");
                }
            } catch (e) {
                console.error("Audio error:", e);
            }
        }

        // Core Game Logic Functions

        function createLevel(currentLevel) {
            // For medium difficulty, use 5 colors and 7 tubes (5 colors + 2 empty)
            const numColors = Math.min(ALL_COLORS.length, 4 + Math.floor((currentLevel - 1) / 2));
            const numTubes = numColors + 2;

            // Create initial state with colors sorted in tubes
            let initialTubes = Array(numTubes).fill().map(() => []);
            
            // Distribute colors evenly
            for (let i = 0; i < numColors; i++) {
                for (let j = 0; j < TUBE_CAPACITY; j++) {
                    initialTubes[i].push(ALL_COLORS[i]);
                }
            }
            
            // Shuffle the tubes to create a puzzle
            let shuffledTubes = shuffleTubes(initialTubes);
            
            // Reset state
            gameState = shuffledTubes;
            history = [JSON.stringify(gameState)];
            selectedTubeIndex = -1;
            movesCount = 0;
            
            // Set target moves based on level complexity
            targetMoves = Math.max(8, numColors * 3 - 2);
            
            document.getElementById('level-number').textContent = currentLevel;
            document.getElementById('moves-counter').textContent = movesCount;
            document.getElementById('target-moves').textContent = targetMoves;

            renderGame();
        }

        function shuffleTubes(tubes) {
            // First, flatten all the tubes
            let allLayers = [];
            tubes.forEach(tube => {
                allLayers = allLayers.concat(tube);
                tube.length = 0; // Clear the tube
            });
            
            // Shuffle the layers
            for (let i = allLayers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allLayers[i], allLayers[j]] = [allLayers[j], allLayers[i]];
            }
            
            // Distribute back to tubes
            let tubeIndex = 0;
            allLayers.forEach(layer => {
                while (tubes[tubeIndex].length >= TUBE_CAPACITY) {
                    tubeIndex = (tubeIndex + 1) % tubes.length;
                }
                tubes[tubeIndex].push(layer);
            });
            
            return tubes;
        }

        function checkWin() {
            for (const tube of gameState) {
                if (tube.length > 0) {
                    if (tube.length !== TUBE_CAPACITY || tube.some(color => color !== tube[0])) {
                        return false;
                    }
                }
            }
            return true;
        }

        function getTopLiquid(tubeIndex) {
            const tube = gameState[tubeIndex];
            if (tube.length === 0) return { color: null, amount: 0 };
            
            const topColor = tube[tube.length - 1];
            let amount = 1;
            for (let i = tube.length - 2; i >= 0; i--) {
                if (tube[i] === topColor) {
                    amount++;
                } else {
                    break;
                }
            }
            return { color: topColor, amount };
        }

        function getPourAmount(fromIndex, toIndex) {
            const fromTube = gameState[fromIndex];
            const toTube = gameState[toIndex];

            if (fromTube.length === 0 || fromIndex === toIndex) return 0;
            
            const { color: topPourColor, amount: topPourAmount } = getTopLiquid(fromIndex);
            
            const availableSpace = TUBE_CAPACITY - toTube.length;
            if (availableSpace === 0) return 0;

            const { color: topDestColor } = getTopLiquid(toIndex);

            if (topDestColor !== null && topDestColor !== topPourColor) {
                return 0;
            }

            const actualPourAmount = Math.min(topPourAmount, availableSpace);
            
            return actualPourAmount;
        }

        function pourLiquid(fromIndex, toIndex, amount) {
            if (amount === 0) {
                playSound('error');
                return false;
            }

            history.push(JSON.stringify(gameState));
            
            const fromTube = gameState[fromIndex];
            const toTube = gameState[toIndex];
            
            const layersToPour = fromTube.splice(-amount, amount);
            toTube.push(...layersToPour);

            movesCount++;
            document.getElementById('moves-counter').textContent = movesCount;
            playSound('pour');
            return true;
        }

        function provideHint() {
            // Find a valid move to suggest
            for (let fromIndex = 0; fromIndex < gameState.length; fromIndex++) {
                if (gameState[fromIndex].length === 0) continue;
                
                for (let toIndex = 0; toIndex < gameState.length; toIndex++) {
                    if (fromIndex === toIndex) continue;
                    
                    const amount = getPourAmount(fromIndex, toIndex);
                    if (amount > 0) {
                        // Highlight the suggested tubes
                        const fromTube = document.getElementById(`tube-${fromIndex}`);
                        const toTube = document.getElementById(`tube-${toIndex}`);
                        
                        fromTube.classList.add('selected');
                        toTube.style.borderColor = '#10B981'; // Green highlight
                        
                        playSound('hint');
                        
                        // Remove highlights after 2 seconds
                        setTimeout(() => {
                            fromTube.classList.remove('selected');
                            toTube.style.borderColor = '#2d3748';
                        }, 2000);
                        
                        return;
                    }
                }
            }
            
            // If no valid move found
            playSound('error');
        }

        // Event Handlers and UI Rendering

        function handleTubeClick(index) {
            const tubeElement = document.getElementById(`tube-${index}`);

            if (selectedTubeIndex === -1) {
                if (gameState[index].length > 0) {
                    selectedTubeIndex = index;
                    tubeElement.classList.add('selected');
                } else {
                    playSound('error');
                }
            } else {
                const fromIndex = selectedTubeIndex;
                const toIndex = index;
                
                const amount = getPourAmount(fromIndex, toIndex);
                
                document.getElementById(`tube-${fromIndex}`).classList.remove('selected');
                selectedTubeIndex = -1;

                if (pourLiquid(fromIndex, toIndex, amount)) {
                    renderGame();
                    
                    setTimeout(() => {
                        if (checkWin()) {
                            playSound('win');
                            document.getElementById('final-moves').textContent = movesCount;
                            document.getElementById('win-modal').classList.remove('hidden');
                        }
                    }, 300);
                } else {
                    renderGame();
                }
            }
            document.getElementById('undo-button').disabled = history.length <= 1;
        }

        function renderGame() {
            const board = document.getElementById('game-board');
            board.innerHTML = '';

            gameState.forEach((tube, index) => {
                const container = document.createElement('div');
                container.className = 'tube-container';
                container.id = `tube-container-${index}`;
                container.onclick = () => handleTubeClick(index);

                const cap = document.createElement('div');
                cap.className = 'tube-cap';
                
                const tubeEl = document.createElement('div');
                tubeEl.className = `tube ${index === selectedTubeIndex ? 'selected' : ''}`;
                tubeEl.id = `tube-${index}`;

                tube.forEach((color, layerIndex) => {
                    const layerEl = document.createElement('div');
                    layerEl.className = `tube-liquid-layer layer-${layerIndex + 1}`;
                    layerEl.style.backgroundColor = color;
                    tubeEl.appendChild(layerEl);
                });

                container.appendChild(cap);
                container.appendChild(tubeEl);
                board.appendChild(container);
            });
        }

        function undoMove() {
            if (history.length > 1) {
                history.pop();
                const previousState = JSON.parse(history[history.length - 1]);
                gameState = previousState;
                
                movesCount = Math.max(0, movesCount - 1);
                document.getElementById('moves-counter').textContent = movesCount;
                selectedTubeIndex = -1;

                renderGame();
                document.getElementById('undo-button').disabled = history.length <= 1;
            }
        }

        // Event Listeners

        document.getElementById('undo-button').onclick = undoMove;
        document.getElementById('restart-button').onclick = () => createLevel(level);
        document.getElementById('hint-button').onclick = provideHint;
        document.getElementById('next-level-button').onclick = () => {
            level++;
            document.getElementById('win-modal').classList.add('hidden');
            createLevel(level);
        };
        
        // Start the game
        window.onload = () => {
            createLevel(level);
            document.getElementById('undo-button').disabled = true;
        };

    </script>
</body>
</html>
